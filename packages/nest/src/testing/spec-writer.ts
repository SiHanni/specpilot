// 목적: "컨트롤러 단위" 테스트 파일을 생성/업서트(upsert)한다.
// - 최초 1회: 전체 파일 생성
// - 이후 실행: 마커(<sp:imports|setup|auto-tests>) 블록만 덮어쓰기(수동 코드는 보존)
//
// 생성되는 스펙은 다음을 자동으로 포함한다:
//  - Nest TestingModule 부팅, Controller/Service 인스턴스 획득
//  - 첫 서비스 호출(Service.method) auto-mock
//  - (가능 시) 핸들러 호출 → 서비스 메서드 호출 여부 검증
//  - 대표 예외 모킹 → 컨트롤러가 전파하는지 검증
//
// 옵션: outDir(기본 'test')

import fs from 'node:fs';
import path from 'node:path';
import type { CollectedRoute } from '../services/scanner.service';
import type { SpecPilotModuleOptions } from '../tokens';
import {
  resolveClassFileAbs,
  getFirstServiceCall,
  getHandlerParamCount,
  generateDtoSampleLiteral,
  findLikelyHttpExceptionForClass,
} from '@specpilot/core';

function ensureDir(filePath: string) {
  fs.mkdirSync(path.dirname(filePath), { recursive: true });
}

function toRelImport(fromFile: string, absTsPath?: string | null) {
  if (!absTsPath) return null;
  let rel = path
    .relative(path.dirname(fromFile), absTsPath)
    .replace(/\\/g, '/');
  rel = rel.replace(/\.ts$/, '');
  if (!rel.startsWith('.')) rel = './' + rel;
  return rel;
}

/** 출력 경로: <outDir>/<Controller>.<method>.spec.ts */
export function resolveControllerSpecFilePath(
  cwd: string,
  route: CollectedRoute,
  opts?: SpecPilotModuleOptions
) {
  const outDir = opts?.outDir || 'test';
  const file = `${route.controllerName}.${route.methodName}.spec.ts`;
  return path.join(cwd, outDir, file);
}

// ──────────────────────────────────────────────────────────────────────────────
// 마커 블록 유틸
function getBlock(
  src: string,
  name: 'imports' | 'setup' | 'auto-tests'
): string | null {
  const re = new RegExp(`// <sp:${name}>\\s*([\\s\\S]*?)\\s*// </sp:${name}>`);
  const m = src.match(re);
  return m ? m[1] : null;
}
function replaceBlock(
  src: string,
  name: 'imports' | 'setup' | 'auto-tests',
  inner: string
): string {
  const re = new RegExp(`(// <sp:${name}>)[\\s\\S]*?(// </sp:${name}>)`);
  if (re.test(src)) return src.replace(re, `$1\n${inner.trim()}\n$2`);
  return src + `\n// <sp:${name}>\n${inner.trim()}\n// </sp:${name}>\n`;
}

// ──────────────────────────────────────────────────────────────────────────────
// 스펙 콘텐츠 생성
function buildControllerSpecContent(
  cwd: string,
  route: CollectedRoute,
  opts?: SpecPilotModuleOptions
) {
  const filePath = resolveControllerSpecFilePath(cwd, route, opts);

  const controllerAbs = resolveClassFileAbs(cwd, route.controllerName);
  const controllerRel = toRelImport(filePath, controllerAbs);

  const first = getFirstServiceCall(
    cwd,
    route.controllerName,
    route.methodName
  );
  const serviceClass = first?.serviceType ?? null;
  const serviceAbs = serviceClass
    ? resolveClassFileAbs(cwd, serviceClass)
    : null;
  const serviceRel = toRelImport(filePath, serviceAbs);

  // ✅ 널 안전 가드: getHandlerParamCount가 null을 반환할 수 있음
  const handlerParamCount = getHandlerParamCount(
    cwd,
    route.controllerName,
    route.methodName
  );
  const canCallHandler =
    typeof handlerParamCount === 'number' && handlerParamCount <= 1;

  // DTO 샘플은 paramTypes가 있을 때만 시도
  const firstParamTypeName =
    (route as any)?.paramTypes?.[0]?.name &&
    typeof (route as any).paramTypes[0].name === 'string'
      ? ((route as any).paramTypes[0].name as string)
      : undefined;

  const dtoSample =
    canCallHandler && firstParamTypeName
      ? generateDtoSampleLiteral(cwd, firstParamTypeName)
      : { ok: false as const, code: '{}' };

  const excHint = serviceClass
    ? findLikelyHttpExceptionForClass(cwd, serviceClass)
    : null;

  const header = `/**
 * AUTO-GENERATED BY specpilot (controller)
 * Controller: ${route.controllerName}
 * Handler:    ${route.methodName} (${route.http?.method ?? 'GET'} ${
    route.http?.path ?? ''
  })
 *
 * 최초 1회 생성 후, 이후 실행에서는 마커(<sp:imports|setup|auto-tests>) 영역만 병합 갱신됩니다.
 */
`;

  const importLines = [
    `import { Test } from '@nestjs/testing';`,
    controllerRel
      ? `import { ${route.controllerName} } from '${controllerRel}';`
      : `// TODO: import { ${route.controllerName} } from '<path-to-controller>';`,
    serviceClass && serviceRel
      ? `import { ${serviceClass} } from '${serviceRel}';`
      : serviceClass
      ? `// TODO: import { ${serviceClass} } from '<path-to-service>';`
      : `// NOTE: 서비스 호출이 감지되지 않았습니다.`,
    excHint
      ? `import { ${excHint.name} } from '${excHint.importFrom}';`
      : `// NOTE: 대표 예외 힌트를 찾지 못했습니다.`,
  ].join('\n');

  const setupBlock = `let controller: ${route.controllerName};
let service: ${serviceClass ?? 'any'};

function makeServiceMock(): any {
  const store: Record<string, any> = {};
  const hasJest = !!((global as any).jest?.fn);
  return new Proxy({}, {
    get(_t, prop: string) {
      if (!store[prop]) {
        store[prop] = hasJest ? jest.fn() : (() => undefined);
      }
      return store[prop];
    }
  });
}

beforeAll(async () => {
  const providers = [];
  ${
    serviceClass
      ? `providers.push({ provide: ${serviceClass}, useValue: makeServiceMock() });`
      : `// 서비스가 감지되지 않아 provider 등록을 생략합니다.`
  }

  const moduleRef = await Test.createTestingModule({
    controllers: [${route.controllerName}],
    providers,
  }).compile();

  controller = moduleRef.get(${route.controllerName});
  ${
    serviceClass
      ? `service = moduleRef.get(${serviceClass});`
      : `service = {} as any;`
  }
});`;

  const autoTests = [
    `it('controller is defined', () => { expect(controller).toBeDefined(); });`,
    serviceClass
      ? `it('service is injected', () => { expect(service).toBeDefined(); });`
      : `// NOTE: 서비스가 감지되지 않아 주입 검증을 생략합니다.`,

    // (가능 시) 핸들러 호출 → 서비스 메서드 호출 여부
    serviceClass && first?.method && canCallHandler
      ? (() => {
          const sample = dtoSample.ok ? dtoSample.code : '{}';
          const callLine =
            (route.http?.method?.toUpperCase?.() ?? 'GET') === 'GET'
              ? `await (controller as any)['${route.methodName}']();`
              : `await (controller as any)['${route.methodName}'](${sample});`;
          return `
it('calls ${serviceClass}.${first.method} when handler executes', async () => {
  const fn = (service as any)['${first.method}'];
  if (typeof fn !== 'function' || !('mock' in fn)) { expect(true).toBe(true); return; }
  ${callLine}
  expect(fn.mock.calls.length).toBeGreaterThanOrEqual(1);
});`;
        })()
      : `// NOTE: 파라미터/서비스 정보가 불충분하여 핸들러 호출 검증을 생략합니다.`,

    // 대표 예외 전파
    serviceClass && first?.method && excHint && canCallHandler
      ? `
it('propagates ${excHint.name} from service', async () => {
  const fn = (service as any)['${first.method}'];
  if (typeof fn !== 'function' || !('mockRejectedValueOnce' in fn)) { expect(true).toBe(true); return; }
  fn.mockRejectedValueOnce(new ${excHint.name}('auto'));
  let forwarded = false;
  try {
    ${
      (route.http?.method?.toUpperCase?.() ?? 'GET') === 'GET'
        ? `await (controller as any)['${route.methodName}']();`
        : `await (controller as any)['${route.methodName}'](${
            dtoSample.ok ? dtoSample.code : '{}'
          });`
    }
  } catch (e: any) {
    forwarded = (e instanceof ${excHint.name});
  }
  expect(forwarded).toBe(true);
});`
      : `// NOTE: 대표 예외 힌트/호출 가능성이 부족하여 예외 전파 케이스를 생략합니다.`,
  ].join('\n\n');

  return `${header}
import 'reflect-metadata';

// <sp:imports>
${importLines}
// </sp:imports>

describe('${route.controllerName}.${route.methodName} (controller)', () => {
// <sp:setup>
${setupBlock}
// </sp:setup>

// <sp:auto-tests>
${autoTests}
// </sp:auto-tests>
});
`;
}

// ──────────────────────────────────────────────────────────────────────────────
// 공개: 생성/업서트

export function writeSpecSkeleton(
  cwd: string,
  route: CollectedRoute,
  opts?: SpecPilotModuleOptions
) {
  const filePath = resolveControllerSpecFilePath(cwd, route, opts);
  if (fs.existsSync(filePath)) {
    return { filePath, created: false };
  }
  const content = buildControllerSpecContent(cwd, route, opts);
  ensureDir(filePath);
  fs.writeFileSync(filePath, content, 'utf8');
  return { filePath, created: true };
}

/** 파일이 있으면 마커 블록만 병합, 없으면 생성 */
export function upsertControllerSpec(
  cwd: string,
  route: CollectedRoute,
  opts?: SpecPilotModuleOptions
) {
  const filePath = resolveControllerSpecFilePath(cwd, route, opts);
  const next = buildControllerSpecContent(cwd, route, opts);

  if (!fs.existsSync(filePath)) {
    ensureDir(filePath);
    fs.writeFileSync(filePath, next, 'utf8');
    return { filePath, created: true, merged: false };
  }

  const prev = fs.readFileSync(filePath, 'utf8');

  const nextImports = getBlock(next, 'imports') ?? '';
  const nextSetup = getBlock(next, 'setup') ?? '';
  const nextAuto = getBlock(next, 'auto-tests') ?? '';

  let merged = prev;
  merged = replaceBlock(merged, 'imports', nextImports);
  merged = replaceBlock(merged, 'setup', nextSetup);
  merged = replaceBlock(merged, 'auto-tests', nextAuto);

  if (merged !== prev) {
    fs.writeFileSync(filePath, merged, 'utf8');
    return { filePath, created: false, merged: true };
  }
  return { filePath, created: false, merged: false };
}
